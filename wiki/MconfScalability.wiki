<font color="red">This is currently a draft.</font>

<wiki:toc max_depth="3" />

= Scaling Mconf =

This document contains a documentation of the infrastructure used for scaling Mconf. It is also a documentation of how the Mconf Network (see more about it at http://mconf.org/m/about/network) works today.

= Methodology =

The scaling of Mconf has been divided in two phases with two distinct objectives:

  * *Objective 1*: increase the limit of simultaneous users in a web conference infrastructure.
  In other words: use several web conference servers in a single infrastructure to increase the limit of users imposed when using a single server. The difference between this infrastructure and a single web conference server shouldn't be noticeable neither for the users nor for the applications that use the system (e.g. !BigBlueButton's integration for Moodle). The infrastructure should be as dynamic as possible (e.g. servers can be added and removed) and as automatic as possible (e.g. new servers can register themselves in the "cloud" of servers).
  * *Objective 2*: increase the limit of users in a single web conference.
  This will imply in increasing the limit of users that a single Mconf-Live server supports and/or enable a single meeting to be held using more that one server.


The objective 1 has been started with start of the second phase of Mconf (Oct. 2011), and the objective 2 should start when the first one is completed.


= Architecture =

The image below shows an overview of the current infrastructure. This architecture solves the problem of our objective 1: use several web conference servers in a single infrastructure.

https://lh4.googleusercontent.com/-vVqH4ZORaGI/UJz8WfrulCI/AAAAAAAAAvY/rJCwvjdDcDg/s1055/Mconf%2520Network%2520-%2520Current%2520Architecture%2520%2528full%2529.png


== <font color="red">1.</font> Front-end ==

The front-end is no different than the current front-ends. Users (with web and mobile devices) will join the conferences through any application that's integrated with Mconf-Live. Examples are the Mconf web portal at http://mconf.org and any of the applications listed at http://www.bigbluebutton.org/open-source-integrations/.

Instead of communicating directly with a !BigBlueButton server, these front-end applications will use the Mconf Load Balancer, that implements the [http://code.google.com/p/bigbluebutton/wiki/API BigBlueButton API]. This means that the front-end applications *will not have to be modified* to use the Mconf infrastructure.

However, the Load Balancer's API currently has some very small differences from !BigBlueButton's API and more could be added in the future, but it is extremely important that, even with these small differences, the existent front-end applications should not need to be adapted to use the Mconf infrastructure. Moreover, nothing should be removed from the API. You can see the documentation of the API [MconfLBAPI in this page].


== <font color="green">2.</font> Web conference back-end ==

This is where the most of our work is directed to currently. The back-end consists of a "cloud" of web conference servers, and two new components: the Mconf Monitoring Server (Nagios) and the Mconf Load Balancer. These components are being developed in Mconf and are explained below.


=== Mconf Monitoring Server (Nagios) ===

The Mconf Monitoring Server uses [http://www.nagios.org/ Nagios], an open source monitoring system that's very flexible and has a large number of users. This server monitors the cloud of web conference servers and provides access to all the monitoring data to users (i.e. using a graphical administration interface) or to applications (i.e. through an API).


==== Checks/reports ====

Nagios provides plugins for several things that should be checked ("checks" or "reports") in a server: HTTP, PING, FTP, etc. These checks can be passive or active: passive checks are sent from a !BigBlueButton server to the Monitoring Server, while active checks are generated by the Monitoring Server to a !BigBlueButton server. For Mconf the following metrics are being monitored:

  * Memory Report: Current usage and total of RAM.
  * Processor Report: Current CPU load.
  * Network Report: Input and output bandwidth usage.
  * Disk Report: Hard disk usage and total space available.
  * !BigBlueButton Report: Informs the number of users, meetings, users with audio and users with video.
  * !BigBlueButton API: Checks if the web conference API is responding correctly.
  * !BigBlueButton Demo Installed: Checks if the demos are installed (they shouldn't).
  * !BigBlueButton Version: Checks if the version of the web conference server is correct.
  * Live Notes Server: Checks if the live notes server (the server that handles the notes module) is running.
  * Port check - Desktop Sharing: Check if the port usage by the desktop sharing is open.
  * Port check - RTMP: Check if the port usage by RTMP is open.
  * Port check - SIP: Check if the port usage by SIP is open.
  * (There's also a default service that checks if the server is online)

There is also another plugin that was implemented to enable a !BigBlueButton server to automatically register itself in the infrastructure.

The intervals in which the Monitoring Server receives these information is configurable. For example, we could use 10 seconds for memory, processor and network reports, and 30 seconds for web conference reports. Also, some of the reports listed above are passive: there's a very simple application installed in the web conference servers that periodically sends information to the configured Monitoring Server. Other reports, such as "`BigBlueButton report`" are active: the Monitoring Server periodically consults each web conference server to get the data.

The interactions between the web conference servers and the Monitoring Server are shown in the item *2.a* in the architecture image.

==== Database and graphics ====

The Monitoring Server was integrated with a [http://oss.oetiker.ch/rrdtool/ RRDtool database] using a plugin called [http://nagiosgraph.sourceforge.net/ nagiosgraph]. This plugin stores all the information received from the monitored servers and also display all information graphically with charts such as the examples in the images below.

https://lh6.googleusercontent.com/-gVlO4i-61sA/UKueb1Pv1AI/AAAAAAAAAv8/6onlD7Zju4Y/s672/rdd-1.png

https://lh3.googleusercontent.com/-f2Tlscq25VA/UKueb194xVI/AAAAAAAAAv8/3GRIrdeXepc/s689/rdd-2.png

This provides us historical data for every single metric being monitored and for every server. We can, for instance, see the number of meetings and users in the past year, see the CPU usage of a server in the past month, or the bandwidth usage of all servers in the past week. 

==== Source Code ====

As already commented, the Monitoring Server uses Nagios, an open source monitoring tool that can be found at: http://www.nagios.org/

Also, all the plugins and tools used with Nagios that were implemented by Mconf are open source and available at: https://github.com/mconf/nagios-etc

=== Mconf Load Balancer ===

Another important element in the infrastructure is the Mconf Load Balancer. It is responsible for deciding in which server a meeting should be created in order to balance the load among all servers in the cloud. It uses the metrics collected by the monitoring system (item *2.b* in the architecture image above) to constantly avail the servers in the infrastructure, so when a user requests a new webconference room, the load balancer uses all the monitoring information to select the most appropriate server to run the conference (item *2.c* in the architecture image above).

See below more details about how the load balancer works.


==== API ====

The API is the entry point for other applications to communicate with the load balancer and the web conference back-end. It can be used to create meetings, see the meetings that are running and get more information about these meetings.

The load balancer implements *the same API* available in the web conference servers, but with a few changes. Mconf-Live has the same API implemented by !BigBlueButton and includes a few changes to it. You can find the documentation about the API of !BigBlueButton at [http://code.google.com/p/bigbluebutton/wiki/API this page], and the changes made on it by Mconf-Live at [MconfLiveApiChanges this page].

Since the load balancer implements the same API, all applications that are already integrated with !BigBlueButton or Mconf-Live *don't need to be changed* to work with the load balancer. This is one of the most important things in the load balancer, since it enables all the integrations that !BigBlueButton already has (see [http://www.bigbluebutton.org/open-source-integrations/ this page]) to be used in this infrastructure.

The few changes that were made in the Load Balancer's API should not break any integration that already works with Mconf-Live/!BigBlueButton. These changes are documented [MconfLBAPI in this page].

Moreover, the load balancer implements the mobile API, so [MconfMobile Mconf-Mobile and BBB-Android] can also connect to the load balancer. See more about this API in the [MconfMobile Mconf-Mobile page] or in the [https://github.com/bigbluebutton/bigbluebutton/blob/master/bbb-api-demo/src/main/webapp/mobile.jsp source code at GitHub].



==== Multiple clients (salts) ====

To access the API, the client applications need to known the salt of the load balancer, just as they would need to access Mconf-Live/!BigBlueButton (see more at http://code.google.com/p/bigbluebutton/wiki/API#API_Security_Model).

To allow multiple applications (also called "clients") to access the same infrastructure, the load balancer is able to create multiple salts. Each application/client/institution has its own salt, and with this the load balancer is able to distinguish the client that is accessing it.

The mobile applications, however, use a different salt to access a web conference server (see more at [http://code.google.com/p/mconf/wiki/MconfMobile#On_BigBlueButton_0.8_(still_on_beta) this page]). This salt has only 5 characters to make it easier to type in a mobile device. In the load balancer, the first 5 characters of the standard salt are used as the kye to mobile applications. So if the standard API salt is "`abcdefghijklmnopqrstuvwxyz123456`", the mobile salt will be "`abcde`".


==== Algorithms ====

The algorithms are the logic behind the load balancing. There are several algorithms implemented in the load balancer, but only one in use. Some of these algorithms are:

  * Select the server with less CPU load;
  * Select the server with less users;
  * Select the server that is geographically nearest to the client.

The algorithm current in use is:

  * *Order the servers by proximity to the client. If there is more than one server in a ~300km radius, select the one that has less CPU load in the moment. Won't consider servers that are not UP, that are not responding properly to the monitoring server, or that have a CPU load higher than ~70%. *


==== Dashboard ====

The Load Balancer has also a Dashboard, a web page that shows in real-time the state of all servers in the network. You can see the dashboard of the Mconf Network at: http://lb.mconf.org.

The main idea of the dashboard is to provide an easy way to the administrators to see the state of the network and easily detect possible problems. The dashboard won't show all the information available in the monitoring server, but a reduced set of information including only what's really important and show it in a compact and easy-to-use interface.


= Chef: software updates =

Before the distributed network, the steps we took to update the version a web conference server were all manual: ssh to the server machine and run a bunch of commands that will update the server. If anything went wrong we had to figure it out and fix it while updating. This approach would be terrible in a distributed network where we have several web conference servers and not a single one. And even worse in the Mconf Network, because since we don't have ssh access to all servers (each institution is responsible for their own servers) it would demand more from the administrators of each institution.

To simplify and automate the process, we started using a software called [http://www.opscode.com/chef/ Chef]. With Chef, a set of ruby scripts (called recipes) are written to automate the installation of *everything* that runs in a web conference server. So from a computer with a basic O.S. installed, we can install the Chef client, run the recipes and it will become a web conference server.

You can see below an image showing how the process of developing new recipes and updating the web conference servers work:

https://lh4.googleusercontent.com/-aES7rhx2LJM/UKvCsi1eJ8I/AAAAAAAAAws/6G1WpQje984/s642/Mconf%2520Network%2520-%2520Chef.png


It starts in a development environment, where new recipes are written to install the new features developed in the web conference software. These recipes are sent to a git repository where they will be available for the Chef server.
The Chef server is then updated: this can be done in more than one way, currently a developer logs into it and downloads the recipes from the git repository.

Meanwhile, the nodes (the web conference servers) are periodically consulting the Chef server to see if there's anything new for them. They will always fetch the recipes and execute them, so if there's anything new it will be installed. If nothing changed in the recipes, they should detect it and shouldn't run anything in the node.

This was just a brief description of how it currently works in the Mconf Network, but Chef is very flexible and can be configured in different ways. In short, the main advantage of using Chef is that the updates can be triggered remotely to *all* nodes in the network, and doesn't require manual configuration in the nodes. Also, the scripts are written in ruby, a dynamic, easy-to-use programming language.

For the Mconf Network, this reduces the work needed from the administrators of each institution, since the updates will be automatic and less error-prone (since all recipes are tested before an update).


== Resources ==

All recipes written for Mconf are open source and available at: https://github.com/mconf/chef-recipes


= Testing =

To test the distributed infrastructure, at Mconf we developed a command line web conference client called BBBot. This application was built in Java, using the libraries also used in Mconf-Mobile and BBB-Android. The bot is able to create and join web conferences, just like a standard browser client, and also to send and receive audio and video.

This application can also be used by anyone that wants to test Mconf-Live/!BigBlueButton servers, be it in a distributed environment or in a single server.

BBBot is open source and is available at: https://github.com/mconf/bbbot



= Recommendations =

A list of technical tips for people using or about to use Mconf's solution for scalability. Specially useful for institutions that want to join the Mconf Network.

  * Learn how the API works by reading:
    * !BigBlueButton's API: http://code.google.com/p/bigbluebutton/wiki/API
    * Mconf-Live's changes: [MconfLiveApiChanges here]
    * The Load Balancer's API: [MconfLBAPI here]
  * Set the HTTP header *`x-forwarded-for`* in your requests to the load balancer. The value of it should be the client's IP, so that the load balancer can properly select an adequate server for him. The load balancer needs this IP to define the location of the client, otherwise it will only know the location of the server that sent the request (your Moodle server, for instance). If you're using Mconf-Web you don't need to do anything, since it already sets this header by default.
  * When creating a meeting, use *`meetingID`* as an internal *random* identifier, and `name` as the proper human readable name of the meeting. Consider that the create can fail if a `meetingID` is duplicated, so check for the response and try again with another `meetingID` if needed.