#summary Video capturing, encoding and publishing explanation.

= Introduction =

This chapter will explain how the video capturing, encoding and publishing was implemented to the MconfMobile. 

= Details =

== The capture layout element ==

There is a layout element:
{{{
/bbb-android/res/layout/video_capture.xml
}}}
It contains a view that is an instance of the VideoCapture class. When this element is part of the layout of an activity X, a new instance of the VideoCapture class will be created when the activity X starts. To add this element to an activity X, just add the following line to the layout file of the activity X.
{{{
<include layout="@layout/video_capture" />
}}}
There is no need to add code related to video to your activity X (it is only needed to add the layout element using the line above) because everything is managed by the VideoCapture class. In other words, it is the VideoCapture class who will decide when it is time to pause, start, stop or resume the video. The only exception to this rule is the Client activity, which allows the user to start or stop the video. So, it is necessary to add the layout element (using the line above) to every activity in the application that is a child of the Client activity.

Note that the layout element has size 1x1. This is necessary because we want to hide the preview from the user, as Android requires that the capture can only occur if it has a preview.

== The VideoCapture class ==
The VideoCapture class (/bbb-android/src/org/mconf/bbb/android/video/VideoCapture.java) is instantiated automatically when an activity which includes the video_capture layout element starts. This class is responsible for deciding when to start, stop, pause and resume the video, based on an user decision or not.

=== The VideoCapture.startCapture method ===
It is can be called by the user (by clicking on the "start video" button on the Client activity), or by the VideoCapture class (when the VideoCapture class decides it should start a capture).

It does the following (in this order): acquires the camera, sets the capture parameters, starts the native side, starts a video publish connection, calls the VideoCapture.resumeCapture method and shows a notification to the user.

=== The VideoCapture.resumeCapture method ===
It can't be called by the user. It is called only by the VideoCapture.startCapture or by the VideoCapture class when it decides it is necessary.

It does the following (in this order): sets the display for preview, prepares the callback to get the captured frames and starts the capture.

=== The VideoCapture.stopCapture method ===
It can be called by the user (by clicking on the "stop video" button on the Client activity), or by the VideoCapture class (when the VideoCapture class decides it should stop a capture).

It does the following (in this order): calls the VideoCapture.pauseCapture method, releases the camera, ends the native side, closes the video publish connection and removes the notification.

=== The VideoCapture.pauseCapture method ===
It can't be called by the user. It is called only by the VideoCapture.stopCapture or by the VideoCapture class when it decides it is necessary.

It does the following (in this order): stops the preview, releases the buffers used for the callback and releases the preview display.

=== VideoCapture decisions ===
As said above, everything is managed by the VideoCapture class. So, where, when and how it decides if the video should be started, stopped, paused or resumed? 

WHERE: It decides it inside the onSurfaceCreated, onSurfaceChanged and onSurfaceDestroyed methods.

WHEN: The onSurfaceCreated method is called on the following situations:
* when a new instance of the VideoCapture class is created. Lets call it CASE 1.
* when the screen is rotated and there is a VideoCapture instance created for that activity. Lets call it CASE 2.
The onSurfaceDestroyed method is called when an activity, which created an instance of the VideoCapture class, is sent to

TO BE CONTINUED